#include<iostream>
using namespace std;
#define MAXV 1000                   /* Максимальное число вершин */

enum edge_class {BACK, FORWARD, CROSS, UNCLASSIFIED};

struct edgenode {
    int y;                          /* Cмежная вершина */
    int weight;                     /* Вес ребра */
    struct edgenode *next;          /* Следующее объект стека */
};

typedef struct {
    edgenode *edges[MAXV + 1];      /* Инцидентные вершины */
    int degree[MAXV + 1];           /* Число входящих ребер */
    int nvertices;                  /* Число вершин в графе */
    int nedges;                     /* Число ребер в графе */
    bool directed;                  /* Ориентированный граф? */
} graph;

int finished = 0;                   /* Конец топологической сортировки? */
int discovered[MAXV + 1];           /* Открытая ли вершина? */
int processed[MAXV + 1];            /* Обработанная ли вершина? */
int sort_result[MAXV + 1];          /* Результат топологической сортировки*/
int to_be_processed[MAXV + 1];      /* Вершины, которые пока не обработаны */

void init_graph(graph *g, bool directed) {
    int i;  /* счетчик */
    g->nvertices = 0;
    g->nedges = 0;
    g->directed = directed;

    for (i = 0; i <= MAXV; i++) {
        g->degree[i] = 0;
        g->edges[i] = NULL;
    }
}

void insert_edge(graph* g, int x, int y, bool directed) {
    edgenode *p;                    /* Временный указатель на ребро */
    p = new edgenode();             /* Выделение памяти под новое ребро */

    p->weight = 0;
    p->y = y;
    p->next = g->edges[x];

    g->edges[x] = p;                /* Связывание нового ребра с вершиной x */

    g->degree[x]++;

    if (directed == false)
        insert_edge(g, y, x, true);
    else
        g->nedges++;
}

void display(graph* g) {
    int i;
    edgenode *p;
    for (i = 1; i <= g->nedges; i++) {
        cout << i << ": ";
        p = g->edges[i];
        while (p != NULL) {
            cout << " " << p->y;
            p = p->next;
        }
        cout << '\n';
    }
    cout << endl;
}

void process_vertex_late(int v) {
    processed[v] = 1;               /* Помечаем вершину как обработанную */
    sort_result[--finished] = v;    /* Результат топологической сортировки */
}

const int MAX_NODES = MAXV;
int entry_time[MAX_NODES] = {0};    /* Инициализация массива entry_time */

edge_class edge_classification(int x, int y) {
    if (discovered[y] && !processed[y]) {
        return BACK;
    }
    else if (processed[y] && (entry_time[y] > entry_time[x])) {
        return FORWARD;
    }
    else if (processed[y] && (entry_time[y] < entry_time[x])) {
        return CROSS;
    }
    else {
        cout << "Warning: unclassified edge ( << x << ',' << y << )\n";
        return UNCLASSIFIED;
    }
}
void process_edge(int x, int y) {
    edge_class clas;                       /* Класс ребра */
    clas = edge_classification(x, y);
    if (clas == BACK)
        cout << "Warning: directed cycle found, not a DAG\n";
}

int next(int x) {
    return to_be_processed[x - 1];
}

/* Стек для топологической сортировки */
struct stack {
    int top;
    int items[MAXV];
} sorted;

/* Функция добавления элемента в стек */
void push(stack *s, int x) {
    if (s->top == MAXV - 1) {
    printf("Error: stack overflow\n");
} else
    s->items[++(s->top)] = x;
}

/* Функция удаления элемента из стека */
int pop(stack *s) { 
    if (s->top == -1) {
    cout << "Error: stack underflow\n";
    return -1;
} else
    return s->items[(s->top)--];
}

/* Функция инициализации стека */
void init_stack(stack *s) {
    s->top = -1;
}

/* Печать элементов стека */
void print_stack(stack *s) {
    for (int i = s->top; i >= 0; i--)
        cout << s->items[i] << " ";
    cout << '\n';
}


/* Топологическая сортировка с помощью поиска в глубину */
void dfs(graph *g, int v) {
    edgenode *p;            /* Указатель для обхода ребер */

    if (finished) return;   /* Ранее обнаружен цикл, выход из рекурсии */

    discovered[v] = 1;      /* Помечаем вершину как открытую */
    to_be_processed[v - 1] = v; /* Запоминаем обрабатываемую вершину */
    p = g->edges[v];        /* Выбираем список ребер для вершины v */
    while (p != NULL) {
        int y = p->y;       /* Следующая вершина для обработки */
        if (discovered[y] == 0)
            dfs(g, y);      /* Рекурсивный вызов для обхода вершину у */
        else if ((!processed[y]) && (g->directed || !discovered[y]))
            process_edge(v, y); /* Обработка ребра (v, y) */
        if (finished)
            return;
        p = p->next;
    }
    process_vertex_late(v);
}

/* Запуск топологической сортировки */
void topsort(graph *g) {
    int i; /* Счетчик */

    finished = g->nvertices;

    for (i = 0; i <= g->nvertices; i++) {
        discovered[i] = 0;  /* Помечаем все вершины как неоткрытые */
        processed[i] = 0;   /* Помечаем все вершины как необработанные */
        to_be_processed[i - 1] = 0; /* Обнуляем массив обрабатываемых вершин */
    }
    for (i = 0; i <= g->nvertices; i++) {
        if (!discovered[i])
            dfs(g, i);      /* Начинаем обход с вершины i */
    }

    print_stack(&sorted);   /* Вывод топологического упорядочивания */
}

int main() {
    graph g;
    init_graph(&g, true);
    
    insert_edge(&g, 1, 2, true);   /* Добавление ребра из вершины 1 в вершину 2 */  
    insert_edge(&g, 2, 3, true);   /* Добавление ребра из вершины 2 в вершину 3 */  
    insert_edge(&g, 3, 4, true);   /* Добавление ребра из вершины 3 в вершину 4 */  
    insert_edge(&g, 4, 1, true);   /* Добавление ребра из вершины 4 в вершину 1 */  
    insert_edge(&g, 4, 2, true);   /* Добавление ребра из вершины 4 в вершину 2 */  

    display(&g);    /* Стображение графа до сортировки */
    topsort(&g);    /* Вызов функции топологической сортировки */
    display(&g);    /* Стображение графа после сортировки */
    return 0;
}
